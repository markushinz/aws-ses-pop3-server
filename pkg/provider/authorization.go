package provider

import (
	"encoding/json"
	"fmt"
	"strings"

	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/aws/credentials"
	"github.com/aws/aws-sdk-go/aws/session"
	"github.com/aws/aws-sdk-go/service/lambda"
)

type Authorization struct {
	Name     string `json:"name"`
	Password string `json:"password"`
}

func CheckAuthorization(user, password, authorizationLambda string, s3Bucket *S3Bucket) (*S3Bucket, error) {
	sess, err := session.NewSession(&aws.Config{
		Region:      aws.String(s3Bucket.Region),
		Credentials: credentials.NewStaticCredentials(s3Bucket.AWSAccessKeyID, s3Bucket.AWSSecretAccessKey, ""),
	})
	if err != nil {
		return nil, err
	}
	svc := lambda.New(sess)
	payload, _ := json.Marshal(Authorization{
		Name:     user,
		Password: password,
	})

	input := &lambda.InvokeInput{
		FunctionName: aws.String(authorizationLambda),
		Payload:      payload,
	}

	result, err := svc.Invoke(input)

	if err != nil {
		fmt.Println(err.Error())
		return nil, err
	} else {
		response := string(result.Payload)
		if response == "\"OK\"" {
			// This section really ought to be generated by (and returned from) the Authorization Lambda.
			originalS3Bucket, err := json.Marshal(&s3Bucket)
			if err != nil {
				return nil, err
			}

			userS3Bucket := S3Bucket{}
			if err = json.Unmarshal(originalS3Bucket, &userS3Bucket); err != nil {
				return nil, err
			}
			prefix := userS3Bucket.Prefix
			if prefix != "" && !strings.HasSuffix(prefix, "/") {
				userS3Bucket.Prefix += "/"
			}
			userS3Bucket.Prefix += user
			return &userS3Bucket, err
		} else {
			return nil, fmt.Errorf("Credentials are not authorized")
		}
	}
}
